<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/client.js | @fnndsc/chrisstoreapi</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cj.js~Collection.html">Collection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/client.js~StoreClient.html">StoreClient</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/exception.js~RequestException.html">RequestException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/request.js~Request.html">Request</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/client.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/** * Imports ***/
import Collection from &apos;./cj&apos;;
import Request from &apos;./request&apos;;
import RequestException from &apos;./exception&apos;;

/**
 * Chris store object.
 *
 * @module client
 */
export default class StoreClient {
  /**
   * Constructor
   *
   * @param {string} storeUrl - url of the ChRIS storeservice
   * @param {Object} [auth=null] - authentication object
   * @param {string} [auth.token] - authentication token
   * @param {number} [timeout=30000] - request timeout
   */
  constructor(storeUrl, auth = null, timeout = 30000) {
    this.storeUrl = storeUrl;
    this.storeQueryUrl = storeUrl + &apos;search/&apos;;
    this.pipelinesUrl = &apos;&apos;;
    this.pipelinesQueryUrl = &apos;&apos;;
    this.auth = auth;
    this.timeout = timeout;
    this.contentType = &apos;application/vnd.collection+json&apos;;
  }

  /**
   * Get a paginated list of plugin data (descriptors) given query search
   * parameters. If no search parameters is given then get the default first
   * page.
   *
   * @param {Object} [searchParams=null] - search parameters
   * @param {number} [searchParams.limit] - page limit
   * @param {number} [searchParams.offset] - page offset
   * @param {string} [searchParams.name] - match plugin name containing this string
   * @param {string} [searchParams.name_latest] - match plugin name containing this string
   * and return only the latest version
   * @param {string} [searchParams.name_exact_latest] - match plugin name exactly with this string
   * and return only the latest version
   * @param {string} [searchParams.dock_image] - match plugin docker image exactly with this string
   * @param {string} [searchParams.public_repo] - match plugin public repository exactly with this string
   * @param {string} [searchParams.type] - match plugin type with this string
   * @param {string} [searchParams.category] - match plugin category containing this string
   * @param {string} [searchParams.owner_username] - match plugin username containing this string
   * @param {string} [searchParams.description] - match plugin description containing this string
   * @param {string} [searchParams.name_title_category] - match plugin name, title or category
   * containing this string
   * @param {string} [searchParams.title] - match plugin title containing this string
   * @param {string} [searchParams.min_creation_date] - match plugin creation date after this date
   * @param {string} [searchParams.max_creation_date] - match plugin creation date before this date
   * @return {Object} - JS Promise
   */
  getPlugins(searchParams = null) {
    let url = this.storeUrl;

    if (searchParams) {
      // then it&apos;s a query and should use the query url
      url = this.storeQueryUrl;
    }
    return this._getListResourceData(url, searchParams);
  }

  /**
   * Get a plugin&apos;s information (descriptors) given its ChRIS store id.
   *
   * @param {number} id - plugin id
   * @return {Object} - JS Promise
   */
  getPlugin(id) {
    return this._getItemResourceData(this.storeQueryUrl, id);
  }

  /**
   * Get a plugin&apos;s paginated parameters given its ChRIS store id.
   *
   * @param {number} pluginId - plugin id
   * @param {Object} [params=null] - page parameters
   * @param {number} [params.limit] - page limit
   * @param {number} [params.offset] - page offset
   * @return {Object} - JS Promise
   */
  getPluginParameters(pluginId, params = null) {
    const url = this.storeQueryUrl;

    return this._getResourceRelatedListData(url, pluginId, &apos;parameters&apos;, params);
  }

  /**
   * Add a new plugin to the ChRIS store.
   *
   * @param {string} name - plugin name
   * @param {string} dockImage - plugin docker image
   * @param {Object} descriptorFile - file blob
   * @param {string} publicRepo - url of the plugin public repository
   * @return {Object} - JS Promise
   */
  addPlugin(name, dockImage, descriptorFile, publicRepo) {
    const req = new Request(this.auth, this.contentType, this.timeout);
    const data = {
      name: name,
      dock_image: dockImage,
      public_repo: publicRepo,
    };

    return req
      .post(this.storeUrl, data, { descriptor_file: descriptorFile })
      .then(resp =&gt; StoreClient.getDataFromCollection(resp.data.collection, &apos;item&apos;));
  }

  /**
   * Modify an existing plugin in the ChRIS store.
   *
   * @param {number} id - plugin id
   * @param {string} publicRepo - url of the plugin public repository
   * @param {string} newOwner - username of a new owner for the plugin
   * @return {Object} - JS Promise
   */
  modifyPlugin(id, publicRepo = &apos;&apos;, newOwner = &apos;&apos;) {
    const self = this;

    return new Promise(function(resolve, reject) {
      StoreClient.runAsyncTask(function*() {
        const req = new Request(self.auth, self.contentType, self.timeout);
        let resp;

        try {
          const searchParams = { id: id };
          const coll = yield self._fetchCollection(self.storeQueryUrl, searchParams);

          if (coll.items.length) {
            const url = coll.items[0].href;
            let data = {};

            if (publicRepo) {
              data.public_repo = publicRepo;
            } else {
              data.public_repo = coll.items[0].data.filter(descriptor =&gt; {
                return descriptor.name === &apos;public_repo&apos;;
              })[0].value;
            }
            if (newOwner) {
              data.owner = newOwner;
            }

            if (self.contentType === &apos;application/vnd.collection+json&apos;) {
              data = { template: Collection.makeTemplate(data) };
            }
            resp = yield req.put(url, data);
          } else {
            const errMsg = &apos;Could not find resource with id: &apos; + id;
            throw new RequestException(errMsg);
          }
        } catch (ex) {
          reject(ex);
          return;
        }

        resolve(StoreClient.getDataFromCollection(resp.data.collection, &apos;item&apos;));
      });
    });
  }

  /**
   * Remove an existing plugin from the ChRIS store.
   *
   * @param {number} id - plugin id
   * @return {Object} - JS Promise
   */
  removePlugin(id) {
    return this._removeItemResource(this.storeQueryUrl, id);
  }

  /**
   * Set the url of the pipelines.
   */
  setPipelinesUrls() {
    return this._fetchCollection(this.storeUrl).then(coll =&gt; {
      this.pipelinesUrl = Collection.getLinkRelationUrls(coll, &apos;pipelines&apos;);
      this.pipelinesQueryUrl = this.pipelinesUrl + &apos;search/&apos;;
    });
  }

  /**
   * Get a paginated list of pipeline data (descriptors) given query search parameters.
   * If no search parameters is given then get the default first page.
   *
   * @param {Object} [searchParams=null] - search parameters
   * @param {number} [searchParams.limit] - page limit
   * @param {number} [searchParams.offset] - page offset
   * @param {string} [searchParams.name] - match pipeline name containing this string
   * @param {string} [searchParams.category] - match pipeline category containing this string
   * @param {string} [searchParams.owner_username] - match pipeline&apos;s owner username exactly with this string
   * @param {string} [searchParams.description] - match pipeline description containing this string
   * @param {string} [searchParams.authors] - match pipeline authors containing this string
   * @param {string} [searchParams.min_creation_date] - match pipeline creation date after this date
   * @param {string} [searchParams.max_creation_date] - match pipeline creation date before this date
   * @param {number} [searchParams.id] - match pipeline id exactly with this number
   * @return {Object} - JS Promise
   */
  getPipelines(searchParams = null) {
    if (searchParams) {
      if (this.pipelinesQueryUrl) {
        return this._getListResourceData(this.pipelinesQueryUrl, searchParams);
      }
      return this.setPipelinesUrls().then(() =&gt;
        this._getListResourceData(this.pipelinesQueryUrl, searchParams)
      );
    }
    if (this.pipelinesUrl) {
      return this._getListResourceData(this.pipelinesUrl);
    }
    return this.setPipelinesUrls().then(() =&gt;
      this._getListResourceData(this.pipelinesUrl, searchParams)
    );
  }

  /**
   * Get a pipeline&apos;s information (descriptors) given its ChRIS store id.
   *
   * @param {number} id - pipeline id
   * @return {Object} - JS Promise
   */
  getPipeline(id) {
    if (this.pipelinesQueryUrl) {
      return this._getItemResourceData(this.pipelinesQueryUrl, id);
    }
    return this.setPipelinesUrls().then(() =&gt;
      this._getItemResourceData(this.pipelinesQueryUrl, id)
    );
  }

  /**
   * Get a pipeline&apos;s paginated default parameters given its ChRIS store id.
   *
   * @param {number} pipelineId - pipeline id
   * @param {Object} [params=null] - page parameters
   * @param {number} [params.limit] - page limit
   * @param {number} [params.offset] - page offset
   * @return {Object} - JS Promise
   */
  getPipelineDefaultParameters(pipelineId, params = null) {
    if (this.pipelinesQueryUrl) {
      return this._getResourceRelatedListData(
        this.pipelinesQueryUrl,
        pipelineId,
        &apos;default_parameters&apos;,
        params
      );
    }
    return this.setPipelinesUrls().then(() =&gt;
      this._getResourceRelatedListData(
        this.pipelinesQueryUrl,
        pipelineId,
        &apos;default_parameters&apos;,
        params
      )
    );
  }

  /**
   * Get a pipeline&apos;s paginated pipings given its ChRIS store id.
   *
   * @param {number} pipelineId - pipeline id
   * @param {Object} [params=null] - page parameters
   * @param {number} [params.limit] - page limit
   * @param {number} [params.offset] - page offset
   * @return {Object} - JS Promise
   */
  getPipelinePipings(pipelineId, params = null) {
    if (this.pipelinesQueryUrl) {
      return this._getResourceRelatedListData(
        this.pipelinesQueryUrl,
        pipelineId,
        &apos;plugin_pipings&apos;,
        params
      );
    }
    return this.setPipelinesUrls().then(() =&gt;
      this._getResourceRelatedListData(this.pipelinesQueryUrl, pipelineId, &apos;plugin_pipings&apos;, params)
    );
  }

  /**
   * Get a pipeline&apos;s paginated plugins given its ChRIS store id.
   *
   * @param {number} pipelineId - pipeline id
   * @param {Object} [params=null] - page parameters
   * @param {number} [params.limit] - page limit
   * @param {number} [params.offset] - page offset
   * @return {Object} - JS Promise
   */
  getPipelinePlugins(pipelineId, params = null) {
    if (this.pipelinesQueryUrl) {
      return this._getResourceRelatedListData(
        this.pipelinesQueryUrl,
        pipelineId,
        &apos;plugins&apos;,
        params
      );
    }
    return this.setPipelinesUrls().then(() =&gt;
      this._getResourceRelatedListData(this.pipelinesQueryUrl, pipelineId, &apos;plugins&apos;, params)
    );
  }

  /**
   * Modify an existing pipeline in the ChRIS store.
   *
   * @param {number} id - pipeline id
   * @param {Object} data - data object with the values for the properties to be modified
   * @param {string} data.name - pipeline&apos;s name
   * @param {string} data.authors - pipeline&apos;s authors
   * @param {string} data.category - pipeline&apos;s category
   * @param {string} data.description - pipeline&apos;s description
   * @return {Object} - JS Promise
   */
  modifyPipeline(id, data) {
    const self = this;

    return new Promise(function(resolve, reject) {
      StoreClient.runAsyncTask(function*() {
        const req = new Request(self.auth, self.contentType, self.timeout);
        let resp;

        try {
          const searchParams = { id: id };
          if (!self.pipelinesQueryUrl) {
            yield self.setPipelinesUrls();
          }
          const coll = yield self._fetchCollection(self.pipelinesQueryUrl, searchParams);
          if (coll.items.length) {
            const url = coll.items[0].href;

            if (self.contentType === &apos;application/vnd.collection+json&apos;) {
              data = { template: Collection.makeTemplate(data) };
            }
            resp = yield req.put(url, data);
          } else {
            const errMsg = &apos;Could not find resource with id: &apos; + id;
            throw new RequestException(errMsg);
          }
        } catch (ex) {
          reject(ex);
          return;
        }

        resolve(StoreClient.getDataFromCollection(resp.data.collection, &apos;item&apos;));
      });
    });
  }

  /**
   * Remove an existing pipeline from the ChRIS store.
   *
   * @param {number} id - pipeline id
   * @return {Object} - JS Promise
   */
  removePipeline(id) {
    if (this.pipelinesQueryUrl) {
      return this._removeItemResource(this.pipelinesQueryUrl, id);
    }
    return this.setPipelinesUrls().then(() =&gt; this._removeItemResource(this.pipelinesQueryUrl, id));
  }

  /**
   * Get currently authenticated user&apos;s information.
   *
   * @return {Object} - JS Promise
   */
  getUser() {
    const storeUrl = this.storeUrl;
    const req = new Request(this.auth, this.contentType, this.timeout);

    return new Promise((resolve, reject) =&gt; {
      StoreClient.runAsyncTask(function*() {
        let resp;

        try {
          resp = yield req.get(storeUrl);
          let userUrls = Collection.getLinkRelationUrls(resp.data.collection, &apos;user&apos;);
          resp = yield req.get(userUrls[0]); // there is only a single user url
        } catch (ex) {
          reject(ex);
          return;
        }

        resolve(StoreClient.getDataFromCollection(resp.data.collection, &apos;item&apos;));
      });
    });
  }

  /**
   * Update currently authenticated user&apos;s information (email and or password).
   *
   * @param {Object} userInfoObj - collection object
   * @param {string} userInfoObj.email - user&apos;s email
   * @param {string} userInfoObj.password - user&apos;s password
   * @return {Object} - JS Promise
   */
  updateUser(userInfoObj) {
    const storeUrl = this.storeUrl;
    const req = new Request(this.auth, this.contentType, this.timeout);

    const userData = {
      template: {
        data: [
          { name: &apos;email&apos;, value: userInfoObj.email },
          { name: &apos;password&apos;, value: userInfoObj.password },
        ],
      },
    };

    return new Promise((resolve, reject) =&gt; {
      StoreClient.runAsyncTask(function*() {
        let resp;

        try {
          resp = yield req.get(storeUrl);
          let userUrls = Collection.getLinkRelationUrls(resp.data.collection, &apos;user&apos;);
          resp = yield req.put(userUrls[0], userData); // there is only a single user url
        } catch (ex) {
          reject(ex);
          return;
        }

        resolve(StoreClient.getDataFromCollection(resp.data.collection, &apos;item&apos;));
      });
    });
  }

  /**
   * Create a new store user account.
   *
   * @param {string} usersUrl - url of the user accounts service
   * @param {string} username - user&apos;s username
   * @param {string} password - user&apos;s password
   * @param {string} email - user&apos;s email
   * @param {number} [timeout=30000] - request timeout
   * @return {Object} - JS Promise
   */
  static createUser(usersUrl, username, password, email, timeout = 30000) {
    const req = new Request(undefined, &apos;application/vnd.collection+json&apos;, timeout);
    const userData = {
      template: {
        data: [
          { name: &apos;username&apos;, value: username },
          { name: &apos;password&apos;, value: password },
          { name: &apos;email&apos;, value: email },
        ],
      },
    };
    return req
      .post(usersUrl, userData)
      .then(resp =&gt; StoreClient.getDataFromCollection(resp.data.collection, &apos;item&apos;));
  }

  /**
   * Get a user&apos;s login authorization token.
   * @param {string} authUrl - url of the authentication service
   * @param {string} username - user&apos;s username
   * @param {string} password - user&apos;s password
   * @param {number} [timeout=30000] - request timeout
   * @return {Object} - JS Promise
   */
  static getAuthToken(authUrl, username, password, timeout = 30000) {
    const req = new Request(undefined, &apos;application/json&apos;, timeout);
    const authData = {
      username: username,
      password: password,
    };
    return req.post(authUrl, authData).then(resp =&gt; resp.data.token);
  }

  /**
   * Helper method to run an asynchronous task defined by a task generator function.
   *
   * @param {function*()} taskGenerator - generator function
   */
  static runAsyncTask(taskGenerator) {
    Request.runAsyncTask(taskGenerator);
  }

  /**
   * Get the data object from a collection object.
   *
   * @param {Object} coll - collection object
   * @param {string} [collection_type=&apos;item&apos;] - collection type, either &apos;list&apos; or &apos;item&apos;
   * @return {Object} - result object
   */
  static getDataFromCollection(coll, collection_type = &apos;item&apos;) {
    const result = {};

    if (collection_type === &apos;list&apos;) {
      result.data = [];

      // for each item get its data
      for (let item of coll.items) {
        result.data.push(Collection.getItemDescriptors(item));
      }
      const next = Collection.getLinkRelationUrls(coll, &apos;next&apos;);
      result.hasNextPage = next.length ? true : false;
      const previous = Collection.getLinkRelationUrls(coll, &apos;previous&apos;);
      result.hasPreviousPage = previous.length ? true : false;
    } else {
      result.data = Collection.getItemDescriptors(coll.items[0]);
    }
    return result;
  }

  /**
   * Internal method to fetch a collection object from a resource url.
   *
   * @param {string} url - url
   * @param {Object} [searchParams=null] - search parameters
   * @return {Object} - JS Promise
   */
  _fetchCollection(url, searchParams = null) {
    const req = new Request(this.auth, this.contentType, this.timeout);

    return req.get(url, searchParams).then(resp =&gt; resp.data.collection);
  }

  /**
   * Internal method to get an item resources&apos;s data (descriptors) given its ChRIS store id.
   *
   * @param {string} resQueryUrl - query url for the resource
   * @param {number} id - plugin id
   * @return {Object} - JS Promise
   */
  _getItemResourceData(resQueryUrl, id) {
    const searchParams = { id: id };

    return this._fetchCollection(resQueryUrl, searchParams).then(coll =&gt; {
      if (coll.items.length) {
        return StoreClient.getDataFromCollection(coll, &apos;item&apos;);
      }
      const errMsg = &apos;Could not find resource with id: &apos; + id;
      throw new RequestException(errMsg);
    });
  }

  /**
   * Internal method to remove an existing item resource from the ChRIS store.
   *
   * @param {string} resQueryUrl - query url for the resource
   * @param {number} id - resource id
   * @return {Object} - JS Promise
   */
  _removeItemResource(resQueryUrl, id) {
    const self = this;

    return new Promise(function(resolve, reject) {
      StoreClient.runAsyncTask(function*() {
        const req = new Request(self.auth, self.contentType, self.timeout);
        const searchParams = { id: id };
        let resp;

        try {
          resp = yield req.get(resQueryUrl, searchParams);
          const coll = resp.data.collection;

          if (coll.items.length) {
            const url = coll.items[0].href;
            resp = yield req.delete(url);
          } else {
            const errMsg = &apos;Could not find resource with id: &apos; + id;
            throw new RequestException(errMsg);
          }
        } catch (ex) {
          reject(ex);
          return;
        }

        resolve();
      });
    });
  }

  /**
   * Internal method to get a paginated list of data (descriptors) given query search
   * parameters. If no search parameters is given then get the default first page.
   *
   * @param {string} resUrl -  url for the list resource
   * @param {Object} [searchParams=null] - search parameters
   * @return {Object} - JS Promise
   */
  _getListResourceData(resUrl, searchParams = null) {
    return this._fetchCollection(resUrl, searchParams).then(coll =&gt; {
      return StoreClient.getDataFromCollection(coll, &apos;list&apos;);
    });
  }

  /**
   * Internal method to get a paginated list of data items related to a resource given
   * by its id.
   *
   * @param {string} resQueryUrl - query url for the resource
   * @param {number} id - resource id
   * @param {string} listRelName - name of the related list link relation
   * @param {Object} [params=null] - page parameters
   * @param {number} [params.limit] - page limit
   * @param {number} [params.offset] - page offset
   * @return {Object} - JS Promise
   */
  _getResourceRelatedListData(resQueryUrl, id, listRelName, params = null) {
    const self = this;

    return new Promise(function(resolve, reject) {
      StoreClient.runAsyncTask(function*() {
        let coll;
        let result = {
          data: [],
          hasNextPage: false,
          hasPreviousPage: false,
        };

        try {
          coll = yield self._fetchCollection(resQueryUrl, { id: id });
          if (coll.items.length === 0) {
            const errMsg = &apos;Could not find resource with id: &apos; + id;
            throw new RequestException(errMsg);
          }
          const listLinks = Collection.getLinkRelationUrls(coll.items[0], listRelName);
          if (listLinks.length) {
            coll = yield self._fetchCollection(listLinks[0], params); // there can only be a single list link
            result = StoreClient.getDataFromCollection(coll, &apos;list&apos;);
          }
        } catch (ex) {
          reject(ex);
          return;
        }

        resolve(result);
      });
    });
  }

  /*export const login = credentials =&gt; {
    return axios.get(&apos;https://jsonplaceholder.typicode.com/posts/1&apos;).then(response =&gt; {
      // process response somehow
    });
  };*/
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
